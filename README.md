# XestiMonitors

[![Swift3](https://img.shields.io/badge/Swift-3.0-blue.svg)](https://developer.apple.com/swift/)
[![License](https://img.shields.io/cocoapods/l/XestiMonitors.svg)](http://cocoapods.org/pods/XestiMonitors)
[![Platform](https://img.shields.io/cocoapods/p/XestiMonitors.svg)](http://cocoapods.org/pods/XestiMonitors)
[![Version](https://img.shields.io/cocoapods/v/XestiMonitors.svg)](http://cocoapods.org/pods/XestiMonitors)

## Contents

* [Overview](#overview)
* [Reference Documentation](#reference_documentation)
* [Requirements](#requirements)
* [Installation](#installation)
* [Usage](#usage)
    * [Application Monitors](#application_monitors)
    * [Device Monitors](#device_monitors)
    * [Other Monitors](#other_monitors)
    * [Custom Monitors](#custom_monitors)
* [Credits](#credits)
* [License](#license)

## <a name="overview">Overview</a>

The XestiMonitors framework provides ...

XestiMonitors provides nearly a dozen fully-functional monitor classes right
out of the box that make it easy for your app to monitor and respond to many
common system-generated events.

## <a name="reference_documentation">Reference Documentation</a>

Full [reference documentation][refdoc] is available courtesy of [Jazzy][jazzy].

## <a name="requirements">Requirements</a>

* iOS 8.0+
* Xcode 8.0+
* Swift 3.0+

## <a name="installation">Installation</a>

XestiMonitors is available through [CocoaPods][cocoapods]. To install it,
simply add the following line to your Podfile:

```ruby
pod 'XestiMonitors'
```

## <a name="usage">Usage</a>

All monitor classes conform to the [Monitor][monitor_protocol] protocol, thus
allowing you the ability to create arrays of monitors that can be started or
stopped uniformly—thereby avoiding more tedious lines of code!

For example, in a custom view controller, you can lazily instantiate several
monitors and, in addition, lazily instantiate an array variable containing
these monitors:

```swift
lazy var keyboardMonitor: KeyboardMonitor = { KeyboardMonitor { /* do something… */ } }()

lazy var memoryMonitor: MemoryMonitor = { MemoryMonitor { /* do something… */ } }()

lazy var orientationMonitor: OrientationMonitor = { OrientationMonitor { /* do something… */ } }()

lazy var monitors: [Monitor] = { [self.keyboardMonitor,
                                  self.memoryMonitor,
                                  self.orientationMonitor] }()
```

In the `viewWillAppear(_:)` and `viewWillDisappear(_:)` methods, you can easily
start or stop this array of monitors with a single line of code:

```swift
override func viewWillAppear(_ animated: Bool) {

    super.viewWillAppear(animated)

    monitors.forEach { $0.startMonitoring() }

}

override func viewWillDisappear(_ animated: Bool) {

    monitors.forEach { $0.stopMonitoring() }

    super.viewWillDisappear(animated)

}
```

### <a name="application_monitors">Application Monitors</a>

XestiMonitors provides seven monitor classes that you can use to observe common
events generated by the system about the app:

* An [ApplicationStateMonitor][application_state_monitor] object monitors the
  app for changes to its runtime state.
* A [BackgroundRefreshMonitor][background_refresh_monitor] object monitors the
  app for changes to its status for downloading content in the background.
* A [MemoryMonitor][memory_monitor] object monitors the app for memory warnings
  from the operating system.
* A [ProtectedDataMonitor][protected_data_monitor] object monitors the app for
  changes to the accessibility of protected files.
* A [ScreenshotMonitor][screenshot_monitor] object monitors the app for
  screenshots.
* A [StatusBarMonitor][status_bar_monitor] object monitors the app for changes
  to the orientation of its user interface or to the frame of the status bar.
* A [TimeMonitor][time_monitor] object monitors the app for significant changes
  in time.

### <a name="device_monitors">Device Monitors</a>

XestiMonitors provides three monitor classes that you can use to easily detect
changes in the characteristics of the current device:

* A [BatteryMonitor][battery_monitor] object monitors the device for changes to
  the charge state and charge level of its battery.
* An [OrientationMonitor][orientation_monitor] object monitors the device for
  changes to its physical orientation.
* A [ProximityMonitor][proximity_monitor] object monitors the device for
  changes to the state of its proximity sensor.

### <a name="other_monitors">Other Monitors</a>

In addition, XestiMonitors provides a [KeyboardMonitor][keyboard_monitor] class
that you can use to monitor the keyboard for changes to its visibility or to
its frame. This monitor is especially handy in removing lots of boilerplate
code from your app.

This is how keyboard monitoring is typically handled in a custom view
controller:

```swift
    func keyboardWillHide(_ notification: NSNotification) {

        let userInfo = notification.userInfo

        var animationDuration: TimeInterval = 0.0

        if let value = (userInfo?[UIKeyboardAnimationDurationUserInfoKey] as? NSNumber)?.doubleValue {
            animationDuration = value
        }

        // do something to view frame…

        UIView.animate(duration: animationDuration,
                       animations: { /* do animations… */ })

    }

    func keyboardWillShow(_ notification: NSNotification) {

        let userInfo = notification.userInfo

        var animationDuration: TimeInterval = 0.0
        var frameEnd = CGRect.zero

        if let value = (userInfo?[UIKeyboardAnimationDurationUserInfoKey] as? NSNumber)?.doubleValue {
            animationDuration = value
        }

        if let value = (userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
            frameEnd = value
        }

        // do something to view frame with frameEnd…

        UIView.animate(duration: animationDuration,
                       animations: { /* do animations… */ })

    }

override func viewWillAppear(_ animated: Bool) {

    super.viewWillAppear(animated)

    let nc = NotificationCenter.`default`

    nc.addObserver(self,
                   selector: #selector(keyboardWillHide(_:)),
                   name: .UIKeyboardWillHide,
                   object: nil)

    nc.addObserver(self,
                   selector: #selector(keyboardWillShow(_:)),
                   name: .UIKeyboardWillShow,
                   object: nil)

}

override func viewWillDisappear(_ animated: Bool) {

    NotificationCenter.`default`.removeObserver(self)

    super.viewWillDisappear(animated)

}
```

And this is the XestiMonitors way using [KeyboardMonitor][keyboard_monitor]:

```swift
lazy var keyboardMonitor: KeyboardMonitor = {

    KeyboardMonitor { event in

        switch event {

            case let .willHide(info):
                
                // do something to view frame…

                UIView.animate(duration: info.animationDuration,
                               animations: { /* do animations… */ })

            case let .willShow(info):

                // do something to view frame with info.frameEnd…

                UIView.animate(duration: info.animationDuration,
                               animations: { /* do animations… */ })

            default:
                break

        }

    }

}()

override func viewWillAppear(_ animated: Bool) {

    super.viewWillAppear(animated)

    keyboardMonitor.startMonitoring()

}

override func viewWillDisappear(_ animated: Bool) {

    keyboardMonitor.stopMonitoring()

    super.viewWillDisappear(animated)

}
```

What’s in *your* wallet?

### <a name="custom_monitors">Custom Monitors</a>

You can implement your own custom monitors very simply by creating a class that
conforms to the [Monitor][monitor_protocol] protocol.

Typically, however, you will want to create a subclass of
[BaseMonitor][base_monitor]. The advantage of using this abstract base class is
that the logic of starting and stopping the monitor only once is taken care of.
Instead of directly implementing the required protocol methods and properties,
you need only override the `configureMonitor()` and `cleanupMonitor()` methods
of the base class. You will *not* be able to override the `startMonitoring()`
and `stopMonitoring()` methods or the `isMonitoring` property—they are declared
`final` in the base class.

If your custom monitor determines events by observing notifications, you should
create a subclass of [BaseNotificationMonitor][base_notification_monitor]
instead. In most cases, you need only override the
`addNotificationObservers(_:)` method. You can also override the
`removeNotificationObservers(_:)` method if your monitor requires extra actions
when the notification observers are removed upon stopping.

## <a name="credits">Credits</a>

J. G. Pusey (ebardx@gmail.com)

## <a name="license">License</a>

XestiMonitors is available under [the MIT license][license].

[cocoapods]:    http://cocoapods.org
[jazzy]:        https://github.com/realm/jazzy
[license]:      https://github.com/eBardX/XestiMonitors/blob/master/LICENSE.md
[refdoc]:       https://eBardX.github.io/XestiMonitors/

[application_state_monitor]:    https://eBardX.github.io/XestiMonitors/Classes/ApplicationStateMonitor.html
[background_refresh_monitor]:   https://eBardX.github.io/XestiMonitors/Classes/BackgroundRefreshMonitor.html
[base_monitor]:                 https://eBardX.github.io/XestiMonitors/Classes/BaseMonitor.html
[base_notification_monitor]:    https://eBardX.github.io/XestiMonitors/Classes/BaseNotificationMonitor.html
[battery_monitor]:              https://eBardX.github.io/XestiMonitors/Classes/BatteryMonitor.html
[keyboard_monitor]:             https://eBardX.github.io/XestiMonitors/Classes/KeyboardMonitor.html
[memory_monitor]:               https://eBardX.github.io/XestiMonitors/Classes/MemoryMonitor.html
[monitor_protocol]:             https://eBardX.github.io/XestiMonitors/Protocols/Monitor.html
[orientation_monitor]:          https://eBardX.github.io/XestiMonitors/Classes/OrientationMonitor.html
[protected_data_monitor]:       https://eBardX.github.io/XestiMonitors/Classes/ProtectedDataMonitor.html
[proximity_monitor]:            https://eBardX.github.io/XestiMonitors/Classes/ProximityMonitor.html
[screenshot_monitor]:           https://eBardX.github.io/XestiMonitors/Classes/ScreenshotMonitor.html
[status_bar_monitor]:           https://eBardX.github.io/XestiMonitors/Classes/StatusBarMonitor.html
[time_monitor]:                 https://eBardX.github.io/XestiMonitors/Classes/TimeMonitor.html
